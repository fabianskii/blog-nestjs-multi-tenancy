{"version":3,"sources":["../../src/register-decorator.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,kBAAkB,EAAC,MAAM,+BAA+B,CAAC;AAEjE,OAAO,EAAC,kBAAkB,EAAC,MAAM,+BAA+B,CAAC;AAEjE,OAAO,EAAC,eAAe,EAAC,MAAM,8BAA8B,CAAC;AAE7D,OAAO,EAAE,gBAAgB,EAAE,MAAM,aAAa,CAAC;AAC/C,OAAO,EAAE,eAAe,EAAE,kBAAkB,EAAE,MAAM,4BAA4B,CAAC;AAyCjF;;GAEG;AACH,MAAM,UAAU,iBAAiB,CAAC,OAAmC;IAEjE,IAAI,aAAuB,CAAC;IAC5B,IAAI,OAAO,CAAC,SAAS,YAAY,QAAQ,EAAE;QACvC,aAAa,GAAG,OAAO,CAAC,SAAqB,CAAC;QAC9C,IAAM,iBAAiB,GAAG,gBAAgB,CAAC,eAAe,CAAC,CAAC,6BAA6B,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAC7G,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;YAC9B,MAAM,0FAAwF,OAAO,CAAC,MAAM,SAAI,OAAO,CAAC,YAAc,CAAC;SAC1I;KACJ;SAAM;QACH,IAAM,WAAS,GAAG,OAAO,CAAC,SAAyC,CAAC;QACpE,aAAa;YAAG;YAYhB,CAAC;YAXG,mCAAQ,GAAR,UAAS,KAAU,EAAE,mBAAyC;gBAC1D,OAAO,WAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;YAC1D,CAAC;YAED,yCAAc,GAAd,UAAe,mBAAyC;gBACpD,IAAI,WAAS,CAAC,cAAc,EAAE;oBAC1B,OAAO,WAAS,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;iBACxD;gBAED,OAAO,EAAE,CAAC;YACd,CAAC;YACL,uBAAC;QAAD,CAZgB,AAYf,GAAA,CAAC;QACF,kBAAkB,EAAE,CAAC,qBAAqB,CAAC,IAAI,kBAAkB,CAAC,aAAa,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;KAClH;IAED,IAAM,sBAAsB,GAA2B;QACnD,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,iBAAiB;QAC9G,MAAM,EAAE,OAAO,CAAC,MAAM;QACtB,YAAY,EAAE,OAAO,CAAC,YAAY;QAClC,iBAAiB,EAAE,OAAO,CAAC,OAAO;QAClC,aAAa,EAAE,aAAa;QAC5B,WAAW,EAAE,OAAO,CAAC,WAAW;KACnC,CAAC;IACF,kBAAkB,EAAE,CAAC,qBAAqB,CAAC,IAAI,kBAAkB,CAAC,sBAAsB,CAAC,CAAC,CAAC;AAC/F,CAAC","file":"register-decorator.js","sourcesContent":["import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n"],"sourceRoot":"."}