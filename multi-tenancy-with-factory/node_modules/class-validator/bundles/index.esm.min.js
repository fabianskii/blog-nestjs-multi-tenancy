import t from"validator";import{PhoneNumberUtil as n}from"google-libphonenumber";class e{constructor(t){this.groups=[],this.always=!1,this.each=!1,this.context=void 0,this.type=t.type,this.target=t.target,this.propertyName=t.propertyName,this.constraints=t.constraints,this.constraintCls=t.constraintCls,this.validationTypeOptions=t.validationTypeOptions,t.validationOptions&&(this.message=t.validationOptions.message,this.groups=t.validationOptions.groups,this.always=t.validationOptions.always,this.each=t.validationOptions.each,this.context=t.validationOptions.context)}}class a{transform(t){const n=[];return Object.keys(t.properties).forEach(a=>{t.properties[a].forEach(r=>{const i={message:r.message,groups:r.groups,always:r.always,each:r.each},s={type:r.type,target:t.name,propertyName:a,constraints:r.constraints,validationTypeOptions:r.options,validationOptions:i};n.push(new e(s))})}),n}}function r(){return"undefined"!=typeof window&&(window.global=window),global.classValidatorMetadataStorage||(global.classValidatorMetadataStorage=new i),global.classValidatorMetadataStorage}class i{constructor(){this.validationMetadatas=[],this.constraintMetadatas=[]}get hasValidationMetaData(){return!!this.validationMetadatas.length}addValidationSchema(t){(new a).transform(t).forEach(t=>this.addValidationMetadata(t))}addValidationMetadata(t){this.validationMetadatas.push(t)}addConstraintMetadata(t){this.constraintMetadatas.push(t)}groupByPropertyName(t){const n={};return t.forEach(t=>{n[t.propertyName]||(n[t.propertyName]=[]),n[t.propertyName].push(t)}),n}getTargetValidationMetadatas(t,n,e){const a=this.validationMetadatas.filter(a=>(a.target===t||a.target===n)&&(!!a.always||(!(e&&e.length>0)||a.groups&&!!a.groups.find(t=>-1!==e.indexOf(t))))),r=this.validationMetadatas.filter(n=>"string"!=typeof n.target&&(n.target!==t&&((!(n.target instanceof Function)||t.prototype instanceof n.target)&&(!!n.always||(!(e&&e.length>0)||n.groups&&!!n.groups.find(t=>-1!==e.indexOf(t))))))).filter(t=>!a.find(n=>n.propertyName===t.propertyName&&n.type===t.type));return a.concat(r)}getTargetValidatorConstraints(t){return this.constraintMetadatas.filter(n=>n.target===t)}}class s{toString(t=!1,n=!1,e=""){const a=t?"[1m":"",r=t?"[22m":"",i=t=>` - property ${a}${e}${t}${r} has failed the following constraints: ${a}${Object.keys(this.constraints).join(", ")}${r} \n`;if(n){const n=Number.isInteger(+this.property)?`[${this.property}]`:`${e?".":""}${this.property}`;return this.constraints?i(n):this.children.map(a=>a.toString(t,!0,`${e}${n}`)).join("")}return`An instance of ${a}${this.target?this.target.constructor.name:"an object"}${r} has failed the validation:\n`+(this.constraints?i(this.property):"")+this.children.map(n=>n.toString(t,!0,this.property)).join("")}}class o{static isValid(t){return"isValid"!==t&&"getMessage"!==t&&-1!==Object.keys(this).map(t=>this[t]).indexOf(t)}}o.CUSTOM_VALIDATION="customValidation",o.NESTED_VALIDATION="nestedValidation",o.PROMISE_VALIDATION="promiseValidation",o.CONDITIONAL_VALIDATION="conditionalValidation",o.WHITELIST="whitelistValidation",o.IS_DEFINED="isDefined";function c(t){return null!==t&&"object"==typeof t&&"function"==typeof t.then}class u{constructor(t,n){this.validator=t,this.validatorOptions=n,this.awaitingPromises=[],this.ignoreAsyncValidations=!1,this.metadataStorage=r()}execute(t,n,e){this.metadataStorage.hasValidationMetaData||console.warn("No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.");const a=this.validatorOptions?this.validatorOptions.groups:void 0,r=this.metadataStorage.getTargetValidationMetadatas(t.constructor,n,a),i=this.metadataStorage.groupByPropertyName(r);if(this.validatorOptions&&this.validatorOptions.forbidUnknownValues&&!r.length){const n=new s;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(n.target=t),n.value=void 0,n.property=void 0,n.children=[],n.constraints={unknownValue:"an unknown value was passed to the validate function"},void e.push(n)}this.validatorOptions&&this.validatorOptions.whitelist&&this.whitelist(t,i,e),Object.keys(i).forEach(n=>{const a=t[n],r=i[n].filter(t=>t.type===o.IS_DEFINED),s=i[n].filter(t=>t.type!==o.IS_DEFINED&&t.type!==o.WHITELIST);a instanceof Promise&&s.find(t=>t.type===o.PROMISE_VALIDATION)?this.awaitingPromises.push(a.then(a=>{this.performValidations(t,a,n,r,s,e)})):this.performValidations(t,a,n,r,s,e)})}whitelist(t,n,e){let a=[];Object.keys(t).forEach(t=>{n[t]&&0!==n[t].length||a.push(t)}),a.length>0&&(this.validatorOptions&&this.validatorOptions.forbidNonWhitelisted?a.forEach(n=>{const a=this.generateValidationError(t,t[n],n);a.constraints={[o.WHITELIST]:`property ${n} should not exist`},a.children=void 0,e.push(a)}):a.forEach(n=>delete t[n]))}stripEmptyErrors(t){return t.filter(t=>{if(t.children&&(t.children=this.stripEmptyErrors(t.children)),0===Object.keys(t.constraints).length){if(0===t.children.length)return!1;delete t.constraints}return!0})}performValidations(t,n,e,a,r,i){const s=r.filter(t=>t.type===o.CUSTOM_VALIDATION),c=r.filter(t=>t.type===o.NESTED_VALIDATION),u=r.filter(t=>t.type===o.CONDITIONAL_VALIDATION),l=this.generateValidationError(t,n,e);i.push(l),this.conditionalValidations(t,n,u)&&(this.customValidations(t,n,a,l),this.mapContexts(t,n,a,l),void 0===n&&this.validatorOptions&&!0===this.validatorOptions.skipUndefinedProperties||null===n&&this.validatorOptions&&!0===this.validatorOptions.skipNullProperties||null==n&&this.validatorOptions&&!0===this.validatorOptions.skipMissingProperties||(this.customValidations(t,n,s,l),this.nestedValidations(n,c,l.children),this.mapContexts(t,n,r,l),this.mapContexts(t,n,s,l)))}generateValidationError(t,n,e){const a=new s;return this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.target&&!0!==this.validatorOptions.validationError.target||(a.target=t),this.validatorOptions&&this.validatorOptions.validationError&&void 0!==this.validatorOptions.validationError.value&&!0!==this.validatorOptions.validationError.value||(a.value=n),a.property=e,a.children=[],a.constraints={},a}conditionalValidations(t,n,e){return e.map(e=>e.constraints[0](t,n)).reduce((t,n)=>t&&n,!0)}customValidations(t,n,e,a){e.forEach(e=>{this.metadataStorage.getTargetValidatorConstraints(e.constraintCls).forEach(r=>{if(r.async&&this.ignoreAsyncValidations)return;const i={targetName:t.constructor?t.constructor.name:void 0,property:e.propertyName,object:t,value:n,constraints:e.constraints};if(!e.each||!(n instanceof Array||n instanceof Set||n instanceof Map)){const s=r.instance.validate(n,i);if(c(s)){const i=s.then(i=>{if(!i){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s,e.context&&(a.contexts||(a.contexts={}),a.contexts[i]=Object.assign(a.contexts[i]||{},e.context))}});this.awaitingPromises.push(i)}else if(!s){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s}return}var s;const o=((s=n)instanceof Map?Array.from(s.values()):Array.isArray(s)?s:Array.from(s)).map(t=>r.instance.validate(t,i));if(o.some(t=>c(t))){const i=o.map(t=>c(t)?t:Promise.resolve(t)),s=Promise.all(i).then(i=>{if(!i.every(t=>t)){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s,e.context&&(a.contexts||(a.contexts={}),a.contexts[i]=Object.assign(a.contexts[i]||{},e.context))}});this.awaitingPromises.push(s)}else if(!o.every(t=>t)){const[i,s]=this.createValidationError(t,n,e,r);a.constraints[i]=s}})})}nestedValidations(t,n,e){void 0!==t&&n.forEach(a=>{if(a.type===o.NESTED_VALIDATION||a.type===o.PROMISE_VALIDATION)if(t instanceof Array||t instanceof Set||t instanceof Map){(t instanceof Set?Array.from(t):t).forEach((a,r)=>{this.performValidations(t,a,r.toString(),[],n,e)})}else if(t instanceof Object){const n="string"==typeof a.target?a.target:a.target.name;this.execute(t,n,e)}else{const n=new s;n.value=t,n.property=a.propertyName,n.target=a.target;const[r,i]=this.createValidationError(a.target,t,a);n.constraints={[r]:i},e.push(n)}})}mapContexts(t,n,e,a){return e.forEach(t=>{if(t.context){let n;if(t.type===o.CUSTOM_VALIDATION){n=this.metadataStorage.getTargetValidatorConstraints(t.constraintCls)[0]}const e=this.getConstraintType(t,n);a.constraints[e]&&(a.contexts||(a.contexts={}),a.contexts[e]=Object.assign(a.contexts[e]||{},t.context))}})}createValidationError(t,n,e,a){const r=t.constructor?t.constructor.name:void 0,i=this.getConstraintType(e,a),s={targetName:r,property:e.propertyName,object:t,value:n,constraints:e.constraints};let o=e.message||"";return e.message||this.validatorOptions&&(!this.validatorOptions||this.validatorOptions.dismissDefaultMessages)||a&&a.instance.defaultMessage instanceof Function&&(o=a.instance.defaultMessage(s)),[i,class{static replaceMessageSpecialTokens(t,n){let e;return t instanceof Function?e=t(n):"string"==typeof t&&(e=t),e&&n.constraints instanceof Array&&n.constraints.forEach((t,n)=>{e=e.replace(new RegExp(`\\$constraint${n+1}`,"g"),t)}),e&&void 0!==n.value&&null!==n.value&&"string"==typeof n.value&&(e=e.replace(/\$value/g,n.value)),e&&(e=e.replace(/\$property/g,n.property)),e&&(e=e.replace(/\$target/g,n.targetName)),e}}.replaceMessageSpecialTokens(o,s)]}getConstraintType(t,n){return n&&n.name?n.name:t.type}}class l{coreValidate(t,n,e){const a="string"==typeof t?n:t,r="string"==typeof t?t:void 0,i=new u(this,"string"==typeof t?e:n),s=[];return i.execute(a,r,s),Promise.all(i.awaitingPromises).then(()=>i.stripEmptyErrors(s))}validate(t,n,e){return this.coreValidate(t,n,e)}async validateOrReject(t,n,e){const a=await this.coreValidate(t,n,e);if(a.length)return Promise.reject(a)}validateSync(t,n,e){const a="string"==typeof t?n:t,r="string"==typeof t?t:void 0,i=new u(this,"string"==typeof t?e:n);i.ignoreAsyncValidations=!0;const s=[];return i.execute(a,r,s),i.stripEmptyErrors(s)}}const d=new class{constructor(){this.instances=[]}get(t){let n=this.instances.find(n=>n.type===t);return n||(n={type:t,object:new t},this.instances.push(n)),n.object}};let p,f;function m(t,n){p=t,f=n}function g(t){if(p)try{const n=p.get(t);if(n)return n;if(!f||!f.fallback)return n}catch(t){if(!f||!f.fallbackOnErrors)throw t}return d.get(t)}function y(t){return function(n,a){const i={type:o.WHITELIST,target:n.constructor,propertyName:a,validationOptions:t};r().addValidationMetadata(new e(i))}}class v{constructor(t,n,e=!1){this.target=t,this.name=n,this.async=e}get instance(){return g(this.target)}}function h(t){let n;if(t.validator instanceof Function){if(n=t.validator,g(i).getTargetValidatorConstraints(t.validator).length>1)throw`More than one implementation of ValidatorConstraintInterface found for validator on: ${t.target}:${t.propertyName}`}else{const e=t.validator;n=class{validate(t,n){return e.validate(t,n)}defaultMessage(t){return e.defaultMessage?e.defaultMessage(t):""}},r().addConstraintMetadata(new v(n,t.name,t.async))}const a={type:t.name&&o.isValid(t.name)?t.name:o.CUSTOM_VALIDATION,target:t.target,propertyName:t.propertyName,validationOptions:t.options,constraintCls:n,constraints:t.constraints};r().addValidationMetadata(new e(a))}function b(t,n){return e=>{const a=n&&n.each?"each value in ":"";return t(a,e)}}function M(t,n){return function(e,a){h({name:t.name,target:e.constructor,propertyName:a,options:n,constraints:t.constraints,validator:t.validator})}}const $=o.IS_DEFINED;function I(t){return null!=t}function O(t){return M({name:$,validator:{validate:t=>I(t),defaultMessage:b(t=>t+"$property should not be null or undefined",t)}},t)}function N(t){return function(n,a){const i={type:o.CONDITIONAL_VALIDATION,target:n.constructor,propertyName:a,constraints:[(t,n)=>null!==t[a]&&void 0!==t[a]],validationOptions:t};r().addValidationMetadata(new e(i))}}function A(t){return function(n){const e=!(!t||!t.async);let a=t&&t.name?t.name:"";a||(a=n.name,a||(a=a.replace(/\.?([A-Z]+)/g,(t,n)=>"_"+n.toLowerCase()).replace(/^_/,"")));const i=new v(n,a,e);r().addConstraintMetadata(i)}}function S(t,n,a){return function(i,s){const c={type:o.CUSTOM_VALIDATION,target:i.constructor,propertyName:s,constraintCls:t,constraints:n instanceof Array?n:void 0,validationOptions:n instanceof Array?a:n};r().addValidationMetadata(new e(c))}}function E(t,n){return function(a,i){const s={type:o.CONDITIONAL_VALIDATION,target:a.constructor,propertyName:i,constraints:[t],validationOptions:n};r().addValidationMetadata(new e(s))}}function V(t){const n={...t},a=n.each?"each value in ":"";return n.message=n.message||a+"nested property $property must be either object or array",function(t,a){const i={type:o.NESTED_VALIDATION,target:t.constructor,propertyName:a,validationOptions:n};r().addValidationMetadata(new e(i))}}function C(t){return function(n,a){const i={type:o.PROMISE_VALIDATION,target:n.constructor,propertyName:a,validationOptions:t};r().addValidationMetadata(new e(i))}}const w="isLatLong";function T(n){return"string"==typeof n&&t.isLatLong(n)}function x(t){return M({name:"isLatLong",validator:{validate:(t,n)=>T(t),defaultMessage:b(t=>t+"$property must be a latitude,longitude string",t)}},t)}const D="isLatitude";function L(t){return("number"==typeof t||"string"==typeof t)&&T(`${t},0`)}function P(t){return M({name:"isLatitude",validator:{validate:(t,n)=>L(t),defaultMessage:b(t=>t+"$property must be a latitude string or number",t)}},t)}const j="isLongitude";function B(t){return("number"==typeof t||"string"==typeof t)&&T(`0,${t}`)}function R(t){return M({name:"isLongitude",validator:{validate:(t,n)=>B(t),defaultMessage:b(t=>t+"$property must be a longitude string or number",t)}},t)}const U="equals";function _(t,n){return t===n}function F(t,n){return M({name:"equals",constraints:[t],validator:{validate:(t,n)=>_(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be equal to $constraint1",n)}},n)}const H="notEquals";function k(t,n){return t!==n}function q(t,n){return M({name:"notEquals",constraints:[t],validator:{validate:(t,n)=>k(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not be equal to $constraint1",n)}},n)}const W="isEmpty";function z(t){return""===t||null==t}function J(t){return M({name:"isEmpty",validator:{validate:(t,n)=>z(t),defaultMessage:b(t=>t+"$property must be empty",t)}},t)}const Z="isNotEmpty";function G(t){return""!==t&&null!=t}function K(t){return M({name:"isNotEmpty",validator:{validate:(t,n)=>G(t),defaultMessage:b(t=>t+"$property should not be empty",t)}},t)}const Q="isIn";function Y(t,n){return!(n instanceof Array)||n.some(n=>n===t)}function X(t,n){return M({name:"isIn",constraints:[t],validator:{validate:(t,n)=>Y(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be one of the following values: $constraint1",n)}},n)}const tt="isNotIn";function nt(t,n){return!(n instanceof Array&&n.some(n=>n===t))}function et(t,n){return M({name:"isNotIn",constraints:[t],validator:{validate:(t,n)=>nt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not be one of the following values: $constraint1",n)}},n)}const at="isDivisibleBy";function rt(n,e){return"number"==typeof n&&"number"==typeof e&&t.isDivisibleBy(String(n),e)}function it(t,n){return M({name:"isDivisibleBy",constraints:[t],validator:{validate:(t,n)=>rt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be divisible by $constraint1",n)}},n)}const st="isPositive";function ot(t){return"number"==typeof t&&t>0}function ct(t){return M({name:"isPositive",validator:{validate:(t,n)=>ot(t),defaultMessage:b(t=>t+"$property must be a positive number",t)}},t)}const ut="isNegative";function lt(t){return"number"==typeof t&&t<0}function dt(t){return M({name:"isNegative",validator:{validate:(t,n)=>lt(t),defaultMessage:b(t=>t+"$property must be a negative number",t)}},t)}const pt="max";function ft(t,n){return"number"==typeof t&&"number"==typeof n&&t<=n}function mt(t,n){return M({name:"max",constraints:[t],validator:{validate:(t,n)=>ft(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must not be greater than $constraint1",n)}},n)}const gt="min";function yt(t,n){return"number"==typeof t&&"number"==typeof n&&t>=n}function vt(t,n){return M({name:"min",constraints:[t],validator:{validate:(t,n)=>yt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must not be less than $constraint1",n)}},n)}const ht="minDate";function bt(t,n){return t instanceof Date&&t.getTime()>=n.getTime()}function Mt(t,n){return M({name:"minDate",constraints:[t],validator:{validate:(t,n)=>bt(t,n.constraints[0]),defaultMessage:b(t=>"minimal allowed date for "+t+"$property is $constraint1",n)}},n)}const $t="maxDate";function It(t,n){return t instanceof Date&&t.getTime()<=n.getTime()}function Ot(t,n){return M({name:"maxDate",constraints:[t],validator:{validate:(t,n)=>It(t,n.constraints[0]),defaultMessage:b(t=>"maximal allowed date for "+t+"$property is $constraint1",n)}},n)}const Nt="contains";function At(n,e){return"string"==typeof n&&t.contains(n,e)}function St(t,n){return M({name:"contains",constraints:[t],validator:{validate:(t,n)=>At(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain a $constraint1 string",n)}},n)}const Et="notContains";function Vt(n,e){return"string"==typeof n&&!t.contains(n,e)}function Ct(t,n){return M({name:"notContains",constraints:[t],validator:{validate:(t,n)=>Vt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not contain a $constraint1 string",n)}},n)}const wt="isAlpha";function Tt(n,e){return"string"==typeof n&&t.isAlpha(n,e)}function xt(t,n){return M({name:"isAlpha",constraints:[t],validator:{validate:(t,n)=>Tt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain only letters (a-zA-Z)",n)}},n)}const Dt="isAlphanumeric";function Lt(n,e){return"string"==typeof n&&t.isAlphanumeric(n,e)}function Pt(t,n){return M({name:"isAlphanumeric",constraints:[t],validator:{validate:(t,n)=>Lt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain only letters and numbers",n)}},n)}const jt="isDecimal";function Bt(n,e){return"string"==typeof n&&t.isDecimal(n,e)}function Rt(t,n){return M({name:"isDecimal",constraints:[t],validator:{validate:(t,n)=>Bt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property is not a valid decimal number.",n)}},n)}const Ut="isAscii";function _t(n){return"string"==typeof n&&t.isAscii(n)}function Ft(t){return M({name:"isAscii",validator:{validate:(t,n)=>_t(t),defaultMessage:b(t=>t+"$property must contain only ASCII characters",t)}},t)}const Ht="isBase64";function kt(n){return"string"==typeof n&&t.isBase64(n)}function qt(t){return M({name:"isBase64",validator:{validate:(t,n)=>kt(t),defaultMessage:b(t=>t+"$property must be base64 encoded",t)}},t)}const Wt="isByteLength";function zt(n,e,a){return"string"==typeof n&&t.isByteLength(n,{min:e,max:a})}function Jt(t,n,e){return M({name:"isByteLength",constraints:[t,n],validator:{validate:(t,n)=>zt(t,n.constraints[0],n.constraints[1]),defaultMessage:b(t=>t+"$property's byte length must fall into ($constraint1, $constraint2) range",e)}},e)}const Zt="isCreditCard";function Gt(n){return"string"==typeof n&&t.isCreditCard(n)}function Kt(t){return M({name:"isCreditCard",validator:{validate:(t,n)=>Gt(t),defaultMessage:b(t=>t+"$property must be a credit card",t)}},t)}const Qt="isCurrency";function Yt(n,e){return"string"==typeof n&&t.isCurrency(n,e)}function Xt(t,n){return M({name:"isCurrency",constraints:[t],validator:{validate:(t,n)=>Yt(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a currency",n)}},n)}const tn="isEmail";function nn(n,e){return"string"==typeof n&&t.isEmail(n,e)}function en(t,n){return M({name:"isEmail",constraints:[t],validator:{validate:(t,n)=>nn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an email",n)}},n)}const an="isFqdn";function rn(n,e){return"string"==typeof n&&t.isFQDN(n,e)}function sn(t,n){return M({name:"isFqdn",constraints:[t],validator:{validate:(t,n)=>rn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid domain name",n)}},n)}const on="isFullWidth";function cn(n){return"string"==typeof n&&t.isFullWidth(n)}function un(t){return M({name:"isFullWidth",validator:{validate:(t,n)=>cn(t),defaultMessage:b(t=>t+"$property must contain a full-width characters",t)}},t)}const ln="isHalfWidth";function dn(n){return"string"==typeof n&&t.isHalfWidth(n)}function pn(t){return M({name:"isHalfWidth",validator:{validate:(t,n)=>dn(t),defaultMessage:b(t=>t+"$property must contain a half-width characters",t)}},t)}const fn="isVariableWidth";function mn(n){return"string"==typeof n&&t.isVariableWidth(n)}function gn(t){return M({name:"isVariableWidth",validator:{validate:(t,n)=>mn(t),defaultMessage:b(t=>t+"$property must contain a full-width and half-width characters",t)}},t)}const yn="isHexColor";function vn(n){return"string"==typeof n&&t.isHexColor(n)}function hn(t){return M({name:"isHexColor",validator:{validate:(t,n)=>vn(t),defaultMessage:b(t=>t+"$property must be a hexadecimal color",t)}},t)}const bn="isHexadecimal";function Mn(n){return"string"==typeof n&&t.isHexadecimal(n)}function $n(t){return M({name:"isHexadecimal",validator:{validate:(t,n)=>Mn(t),defaultMessage:b(t=>t+"$property must be a hexadecimal number",t)}},t)}function In(t){return!!t&&("each"in t||"message"in t||"groups"in t||"always"in t||"context"in t)}const On="isMacAddress";function Nn(n,e){return"string"==typeof n&&t.isMACAddress(n,e)}function An(t,n){const e=In(t)?void 0:t,a=In(t)?t:n;return M({name:"isMacAddress",constraints:[e],validator:{validate:(t,n)=>Nn(t,e),defaultMessage:b(t=>t+"$property must be a MAC Address",a)}},a)}const Sn="isIp";function En(n,e){const a=e?`${e}`:void 0;return"string"==typeof n&&t.isIP(n,a)}function Vn(t,n){return M({name:"isIp",constraints:[t],validator:{validate:(t,n)=>En(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an ip address",n)}},n)}const Cn="isPort";function wn(n){return"string"==typeof n&&t.isPort(n)}function Tn(t){return M({name:"isPort",validator:{validate:(t,n)=>wn(t),defaultMessage:b(t=>t+"$property must be a port",t)}},t)}const xn="isIsbn";function Dn(n,e){const a=e?`${e}`:void 0;return"string"==typeof n&&t.isISBN(n,a)}function Ln(t,n){return M({name:"isIsbn",constraints:[t],validator:{validate:(t,n)=>Dn(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an ISBN",n)}},n)}const Pn="isIsin";function jn(n){return"string"==typeof n&&t.isISIN(n)}function Bn(t){return M({name:"isIsin",validator:{validate:(t,n)=>jn(t),defaultMessage:b(t=>t+"$property must be an ISIN (stock/security identifier)",t)}},t)}const Rn="isIso8601";function Un(n,e){return"string"==typeof n&&t.isISO8601(n,e)}function _n(t,n){return M({name:"isIso8601",constraints:[t],validator:{validate:(t,n)=>Un(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid ISO 8601 date string",n)}},n)}const Fn="isJson";function Hn(n){return"string"==typeof n&&t.isJSON(n)}function kn(t){return M({name:"isJson",validator:{validate:(t,n)=>Hn(t),defaultMessage:b(t=>t+"$property must be a json string",t)}},t)}const qn="isJwt";function Wn(n){return"string"==typeof n&&t.isJWT(n)}function zn(t){return M({name:"isJwt",validator:{validate:(t,n)=>Wn(t),defaultMessage:b(t=>t+"$property must be a jwt string",t)}},t)}const Jn="isLowercase";function Zn(n){return"string"==typeof n&&t.isLowercase(n)}function Gn(t){return M({name:"isLowercase",validator:{validate:(t,n)=>Zn(t),defaultMessage:b(t=>t+"$property must be a lowercase string",t)}},t)}const Kn="isMobilePhone";function Qn(n,e,a){return"string"==typeof n&&t.isMobilePhone(n,e,a)}function Yn(t,n,e){return M({name:"isMobilePhone",constraints:[t,n],validator:{validate:(t,n)=>Qn(t,n.constraints[0],n.constraints[1]),defaultMessage:b(t=>t+"$property must be a phone number",e)}},e)}const Xn="isISO31661Alpha2";function te(n){return"string"==typeof n&&t.isISO31661Alpha2(n)}function ne(t){return M({name:"isISO31661Alpha2",validator:{validate:(t,n)=>te(t),defaultMessage:b(t=>t+"$property must be a valid ISO31661 Alpha2 code",t)}},t)}const ee="isISO31661Alpha3";function ae(n){return"string"==typeof n&&t.isISO31661Alpha3(n)}function re(t){return M({name:"isISO31661Alpha3",validator:{validate:(t,n)=>ae(t),defaultMessage:b(t=>t+"$property must be a valid ISO31661 Alpha3 code",t)}},t)}const ie="isMongoId";function se(n){return"string"==typeof n&&t.isMongoId(n)}function oe(t){return M({name:"isMongoId",validator:{validate:(t,n)=>se(t),defaultMessage:b(t=>t+"$property must be a mongodb id",t)}},t)}const ce="isMultibyte";function ue(n){return"string"==typeof n&&t.isMultibyte(n)}function le(t){return M({name:"isMultibyte",validator:{validate:(t,n)=>ue(t),defaultMessage:b(t=>t+"$property must contain one or more multibyte chars",t)}},t)}const de="isSurrogatePair";function pe(n){return"string"==typeof n&&t.isSurrogatePair(n)}function fe(t){return M({name:"isSurrogatePair",validator:{validate:(t,n)=>pe(t),defaultMessage:b(t=>t+"$property must contain any surrogate pairs chars",t)}},t)}const me="isUrl";function ge(n,e){return"string"==typeof n&&t.isURL(n,e)}function ye(t,n){return M({name:"isUrl",constraints:[t],validator:{validate:(t,n)=>ge(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an URL address",n)}},n)}const ve="isUuid";function he(n,e){return"string"==typeof n&&t.isUUID(n,e)}function be(t,n){return M({name:"isUuid",constraints:[t],validator:{validate:(t,n)=>he(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be an UUID",n)}},n)}const Me="IsFirebasePushId";function $e(t){return"string"==typeof t&&20===t.length&&/^[a-zA-Z0-9_-]*$/.test(t)}function Ie(t){return M({name:"IsFirebasePushId",validator:{validate:(t,n)=>$e(t),defaultMessage:b(t=>t+"$property must be a Firebase Push Id",t)}},t)}const Oe="isUppercase";function Ne(n){return"string"==typeof n&&t.isUppercase(n)}function Ae(t){return M({name:"isUppercase",validator:{validate:(t,n)=>Ne(t),defaultMessage:b(t=>t+"$property must be uppercase",t)}},t)}const Se="length";function Ee(n,e,a){return"string"==typeof n&&t.isLength(n,{min:e,max:a})}function Ve(t,n,e){return M({name:"length",constraints:[t,n],validator:{validate:(t,n)=>Ee(t,n.constraints[0],n.constraints[1]),defaultMessage:b((t,n)=>{const e=null!==n.constraints[0]&&void 0!==n.constraints[0],a=null!==n.constraints[1]&&void 0!==n.constraints[1];return e&&(!n.value||n.value.length<n.constraints[0])?t+"$property must be longer than or equal to $constraint1 characters":a&&n.value.length>n.constraints[1]?t+"$property must be shorter than or equal to $constraint2 characters":t+"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters"},e)}},e)}const Ce="maxLength";function we(n,e){return"string"==typeof n&&t.isLength(n,{min:0,max:e})}function Te(t,n){return M({name:"maxLength",constraints:[t],validator:{validate:(t,n)=>we(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be shorter than or equal to $constraint1 characters",n)}},n)}const xe="minLength";function De(n,e){return"string"==typeof n&&t.isLength(n,{min:e})}function Le(t,n){return M({name:"minLength",constraints:[t],validator:{validate:(t,n)=>De(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be longer than or equal to $constraint1 characters",n)}},n)}const Pe="matches";function je(n,e,a){return"string"==typeof n&&t.matches(n,e,a)}function Be(t,n,e){let a;return n&&n instanceof Object&&!e?e=n:a=n,M({name:"matches",constraints:[t,a],validator:{validate:(t,n)=>je(t,n.constraints[0],n.constraints[0]),defaultMessage:b((t,n)=>t+"$property must match $constraint1 regular expression",e)}},e)}const Re="isPhoneNumber";function Ue(t,e){const a=n.getInstance();try{const n=a.parseAndKeepRawInput(t,e);return a.isValidNumber(n)}catch(t){return!1}}function _e(t,n){return M({name:"isPhoneNumber",constraints:[t],validator:{validate:(t,n)=>Ue(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid phone number",n)}},n)}const Fe="isMilitaryTime";function He(n){return"string"==typeof n&&t.matches(n,/^([01]\d|2[0-3]):?([0-5]\d)$/)}function ke(t){return M({name:"isMilitaryTime",validator:{validate:(t,n)=>He(t),defaultMessage:b(t=>t+"$property must be a valid representation of military time in the format HH:MM",t)}},t)}const qe="isHash";function We(n,e){return"string"==typeof n&&t.isHash(n,e)}function ze(t,n){return M({name:"isHash",constraints:[t],validator:{validate:(t,n)=>We(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a hash of type $constraint1",n)}},n)}const Je="isISSN";function Ze(n,e){return"string"==typeof n&&t.isISSN(n,e)}function Ge(t,n){return M({name:"isISSN",constraints:[t],validator:{validate:(t,n)=>Ze(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a ISSN",n)}},n)}const Ke="isDateString";function Qe(t){return"string"==typeof t&&/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:Z|[\+\-][0-2]\d(?:\:[0-5]\d)?)?$/g.test(t)}function Ye(t){return M({name:"isDateString",validator:{validate:(t,n)=>Qe(t),defaultMessage:b(t=>t+"$property must be a ISOString",t)}},t)}const Xe="isBooleanString";function ta(n){return"string"==typeof n&&t.isBoolean(n)}function na(t){return M({name:"isBooleanString",validator:{validate:(t,n)=>ta(t),defaultMessage:b(t=>t+"$property must be a boolean string",t)}},t)}const ea="isNumberString";function aa(n,e){return"string"==typeof n&&t.isNumeric(n,e)}function ra(t,n){return M({name:"isNumberString",constraints:[t],validator:{validate:(t,n)=>aa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a number string",n)}},n)}const ia="isBase32";function sa(n){return"string"==typeof n&&t.isBase32(n)}function oa(t){return M({name:"isBase32",validator:{validate:(t,n)=>sa(t),defaultMessage:b(t=>t+"$property must be base32 encoded",t)}},t)}const ca="isBIC";function ua(n){return"string"==typeof n&&t.isBIC(n)}function la(t){return M({name:"isBIC",validator:{validate:(t,n)=>ua(t),defaultMessage:b(t=>t+"$property must be a BIC or SWIFT code",t)}},t)}const da="isBtcAddress";function pa(n){return"string"==typeof n&&t.isBtcAddress(n)}function fa(t){return M({name:"isBtcAddress",validator:{validate:(t,n)=>pa(t),defaultMessage:b(t=>t+"$property must be a BTC address",t)}},t)}const ma="isDataURI";function ga(n){return"string"==typeof n&&t.isDataURI(n)}function ya(t){return M({name:"isDataURI",validator:{validate:(t,n)=>ga(t),defaultMessage:b(t=>t+"$property must be a data uri format",t)}},t)}const va="isEAN";function ha(n){return"string"==typeof n&&t.isEAN(n)}function ba(t){return M({name:"isEAN",validator:{validate:(t,n)=>ha(t),defaultMessage:b(t=>t+"$property must be an EAN (European Article Number)",t)}},t)}const Ma="isEthereumAddress";function $a(n){return"string"==typeof n&&t.isEthereumAddress(n)}function Ia(t){return M({name:"isEthereumAddress",validator:{validate:(t,n)=>$a(t),defaultMessage:b(t=>t+"$property must be an Ethereum address",t)}},t)}const Oa="isHSL";function Na(n){return"string"==typeof n&&t.isHSL(n)}function Aa(t){return M({name:"isHSL",validator:{validate:(t,n)=>Na(t),defaultMessage:b(t=>t+"$property must be a HSL color",t)}},t)}const Sa="isIBAN";function Ea(n){return"string"==typeof n&&t.isIBAN(n)}function Va(t){return M({name:"isIBAN",validator:{validate:(t,n)=>Ea(t),defaultMessage:b(t=>t+"$property must be an IBAN",t)}},t)}const Ca="isIdentityCard";function wa(n,e){return"string"==typeof n&&t.isIdentityCard(n,e)}function Ta(t,n){return M({name:"isIdentityCard",constraints:[t],validator:{validate:(t,n)=>wa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a identity card number",n)}},n)}const xa="isISRC";function Da(n){return"string"==typeof n&&t.isISRC(n)}function La(t){return M({name:"isISRC",validator:{validate:(t,n)=>Da(t),defaultMessage:b(t=>t+"$property must be an ISRC",t)}},t)}const Pa="isLocale";function ja(n){return"string"==typeof n&&t.isLocale(n)}function Ba(t){return M({name:"isLocale",validator:{validate:(t,n)=>ja(t),defaultMessage:b(t=>t+"$property must be locale",t)}},t)}const Ra="isMagnetURI";function Ua(n){return"string"==typeof n&&t.isMagnetURI(n)}function _a(t){return M({name:"isMagnetURI",validator:{validate:(t,n)=>Ua(t),defaultMessage:b(t=>t+"$property must be magnet uri format",t)}},t)}const Fa="isMimeType";function Ha(n){return"string"==typeof n&&t.isMimeType(n)}function ka(t){return M({name:"isMimeType",validator:{validate:(t,n)=>Ha(t),defaultMessage:b(t=>t+"$property must be MIME type format",t)}},t)}const qa="isOctal";function Wa(n){return"string"==typeof n&&t.isOctal(n)}function za(t){return M({name:"isOctal",validator:{validate:(t,n)=>Wa(t),defaultMessage:b(t=>t+"$property must be valid octal number",t)}},t)}const Ja="isPassportNumber";function Za(n,e){return"string"==typeof n&&t.isPassportNumber(n,e)}function Ga(t,n){return M({name:"isPassportNumber",constraints:[t],validator:{validate:(t,n)=>Za(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be valid passport number",n)}},n)}const Ka="isPostalCode";function Qa(n,e){return"string"==typeof n&&t.isPostalCode(n,e)}function Ya(t,n){return M({name:"isPostalCode",constraints:[t],validator:{validate:(t,n)=>Qa(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a postal code",n)}},n)}const Xa="isRFC3339";function tr(n){return"string"==typeof n&&t.isRFC3339(n)}function nr(t){return M({name:"isRFC3339",validator:{validate:(t,n)=>tr(t),defaultMessage:b(t=>t+"$property must be RFC 3339 date",t)}},t)}const er="isRgbColor";function ar(n,e){return"string"==typeof n&&t.isRgbColor(n,e)}function rr(t,n){return M({name:"isRgbColor",constraints:[t],validator:{validate:(t,n)=>ar(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be RGB color",n)}},n)}const ir="isSemVer";function sr(n){return"string"==typeof n&&t.isSemVer(n)}function or(t){return M({name:"isSemVer",validator:{validate:(t,n)=>sr(t),defaultMessage:b(t=>t+"$property must be a Semantic Versioning Specification",t)}},t)}const cr="isBoolean";function ur(t){return t instanceof Boolean||"boolean"==typeof t}function lr(t){return M({name:"isBoolean",validator:{validate:(t,n)=>ur(t),defaultMessage:b(t=>t+"$property must be a boolean value",t)}},t)}const dr="isDate";function pr(t){return t instanceof Date&&!isNaN(t.getTime())}function fr(t){return M({name:"isDate",validator:{validate:(t,n)=>pr(t),defaultMessage:b(t=>t+"$property must be a Date instance",t)}},t)}const mr="isNumber";function gr(t,n={}){if("number"!=typeof t)return!1;if(t===1/0||t===-1/0)return n.allowInfinity;if(Number.isNaN(t))return n.allowNaN;if(void 0!==n.maxDecimalPlaces){let e=0;if(t%1!=0&&(e=t.toString().split(".")[1].length),e>n.maxDecimalPlaces)return!1}return Number.isFinite(t)}function yr(t={},n){return M({name:"isNumber",constraints:[t],validator:{validate:(t,n)=>gr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a number conforming to the specified constraints",n)}},n)}const vr="isEnum";function hr(t,n){return Object.keys(n).map(t=>n[t]).indexOf(t)>=0}function br(t,n){return M({name:"isEnum",constraints:[t],validator:{validate:(t,n)=>hr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must be a valid enum value",n)}},n)}const Mr="isInt";function $r(t){return"number"==typeof t&&Number.isInteger(t)}function Ir(t){return M({name:"isInt",validator:{validate:(t,n)=>$r(t),defaultMessage:b(t=>t+"$property must be an integer number",t)}},t)}const Or="isString";function Nr(t){return t instanceof String||"string"==typeof t}function Ar(t){return M({name:"isString",validator:{validate:(t,n)=>Nr(t),defaultMessage:b(t=>t+"$property must be a string",t)}},t)}const Sr="isArray";function Er(t){return t instanceof Array}function Vr(t){return M({name:"isArray",validator:{validate:(t,n)=>Er(t),defaultMessage:b(t=>t+"$property must be an array",t)}},t)}const Cr="isObject";function wr(t){return null!=t&&("object"==typeof t||"function"==typeof t)&&!Array.isArray(t)}function Tr(t){return M({name:"isObject",validator:{validate:(t,n)=>wr(t),defaultMessage:b(t=>t+"$property must be an object",t)}},t)}const xr="arrayContains";function Dr(t,n){return t instanceof Array&&n.every(n=>-1!==t.indexOf(n))}function Lr(t,n){return M({name:"arrayContains",constraints:[t],validator:{validate:(t,n)=>Dr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain $constraint1 values",n)}},n)}const Pr="arrayNotContains";function jr(t,n){return t instanceof Array&&n.every(n=>-1===t.indexOf(n))}function Br(t,n){return M({name:"arrayNotContains",constraints:[t],validator:{validate:(t,n)=>jr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property should not contain $constraint1 values",n)}},n)}const Rr="arrayNotEmpty";function Ur(t){return t instanceof Array&&t.length>0}function _r(t){return M({name:"arrayNotEmpty",validator:{validate:(t,n)=>Ur(t),defaultMessage:b(t=>t+"$property should not be empty",t)}},t)}const Fr="arrayMinSize";function Hr(t,n){return t instanceof Array&&t.length>=n}function kr(t,n){return M({name:"arrayMinSize",constraints:[t],validator:{validate:(t,n)=>Hr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain at least $constraint1 elements",n)}},n)}const qr="arrayMaxSize";function Wr(t,n){return t instanceof Array&&t.length<=n}function zr(t,n){return M({name:"arrayMaxSize",constraints:[t],validator:{validate:(t,n)=>Wr(t,n.constraints[0]),defaultMessage:b(t=>t+"$property must contain not more than $constraint1 elements",n)}},n)}const Jr="arrayUnique";function Zr(t){if(!(t instanceof Array))return!1;const n=t.filter((t,n,e)=>e.indexOf(t)===n);return t.length===n.length}function Gr(t){return M({name:"arrayUnique",validator:{validate:(t,n)=>Zr(t),defaultMessage:b(t=>t+"All $property's elements must be unique",t)}},t)}const Kr="isNotEmptyObject";function Qr(t){if(!wr(t))return!1;for(const n in t)if(t.hasOwnProperty(n))return!0;return!1}function Yr(t){return M({name:"isNotEmptyObject",validator:{validate:(t,n)=>Qr(t),defaultMessage:b(t=>t+"$property must be a non-empty object",t)}},t)}const Xr="isInstance";function ti(t,n){return n&&"function"==typeof n&&t instanceof n}function ni(t,n){return M({name:"isInstance",constraints:[t],validator:{validate:(t,n)=>ti(t,n.constraints[0]),defaultMessage:b((t,n)=>n.constraints[0]?t+`$property must be an instance of ${n.constraints[0].name}`:t+"isInstance decorator expects and object as value, but got falsy value.",n)}},n)}function ei(t,n,e){return"string"==typeof t?g(l).validate(t,n,e):g(l).validate(t,n)}function ai(t,n,e){return"string"==typeof t?g(l).validateOrReject(t,n,e):g(l).validateOrReject(t,n)}function ri(t,n,e){return"string"==typeof t?g(l).validateSync(t,n,e):g(l).validateSync(t,n)}function ii(t){r().addValidationSchema(t)}export{xr as ARRAY_CONTAINS,qr as ARRAY_MAX_SIZE,Fr as ARRAY_MIN_SIZE,Pr as ARRAY_NOT_CONTAINS,Rr as ARRAY_NOT_EMPTY,Jr as ARRAY_UNIQUE,y as Allow,Lr as ArrayContains,zr as ArrayMaxSize,kr as ArrayMinSize,Br as ArrayNotContains,_r as ArrayNotEmpty,Gr as ArrayUnique,Nt as CONTAINS,St as Contains,U as EQUALS,F as Equals,wt as IS_ALPHA,Dt as IS_ALPHANUMERIC,Sr as IS_ARRAY,Ut as IS_ASCII,ia as IS_BASE32,Ht as IS_BASE64,ca as IS_BIC,cr as IS_BOOLEAN,Xe as IS_BOOLEAN_STRING,da as IS_BTC_ADDRESS,Wt as IS_BYTE_LENGTH,Zt as IS_CREDIT_CARD,Qt as IS_CURRENCY,ma as IS_DATA_URI,dr as IS_DATE,Ke as IS_DATE_STRING,jt as IS_DECIMAL,$ as IS_DEFINED,at as IS_DIVISIBLE_BY,va as IS_EAN,tn as IS_EMAIL,W as IS_EMPTY,vr as IS_ENUM,Ma as IS_ETHEREUM_ADDRESS,Me as IS_FIREBASE_PUSH_ID,an as IS_FQDN,on as IS_FULL_WIDTH,ln as IS_HALF_WIDTH,qe as IS_HASH,bn as IS_HEXADECIMAL,yn as IS_HEX_COLOR,Oa as IS_HSL,Sa as IS_IBAN,Ca as IS_IDENTITY_CARD,Q as IS_IN,Xr as IS_INSTANCE,Mr as IS_INT,Sn as IS_IP,xn as IS_ISBN,Pn as IS_ISIN,Xn as IS_ISO31661_ALPHA_2,ee as IS_ISO31661_ALPHA_3,Rn as IS_ISO8601,xa as IS_ISRC,Je as IS_ISSN,Fn as IS_JSON,qn as IS_JWT,D as IS_LATITUDE,w as IS_LATLONG,Pa as IS_LOCALE,j as IS_LONGITUDE,Jn as IS_LOWERCASE,On as IS_MAC_ADDRESS,Ra as IS_MAGNET_URI,Fe as IS_MILITARY_TIME,Fa as IS_MIME_TYPE,Kn as IS_MOBILE_PHONE,ie as IS_MONGO_ID,ce as IS_MULTIBYTE,ut as IS_NEGATIVE,Z as IS_NOT_EMPTY,Kr as IS_NOT_EMPTY_OBJECT,tt as IS_NOT_IN,mr as IS_NUMBER,ea as IS_NUMBER_STRING,Cr as IS_OBJECT,qa as IS_OCTAL,Ja as IS_PASSPORT_NUMBER,Re as IS_PHONE_NUMBER,Cn as IS_PORT,st as IS_POSITIVE,Ka as IS_POSTAL_CODE,Xa as IS_RFC_3339,er as IS_RGB_COLOR,ir as IS_SEM_VER,Or as IS_STRING,de as IS_SURROGATE_PAIR,Oe as IS_UPPERCASE,me as IS_URL,ve as IS_UUID,fn as IS_VARIABLE_WIDTH,xt as IsAlpha,Pt as IsAlphanumeric,Vr as IsArray,Ft as IsAscii,la as IsBIC,oa as IsBase32,qt as IsBase64,lr as IsBoolean,na as IsBooleanString,fa as IsBtcAddress,Jt as IsByteLength,Kt as IsCreditCard,Xt as IsCurrency,ya as IsDataURI,fr as IsDate,Ye as IsDateString,Rt as IsDecimal,O as IsDefined,it as IsDivisibleBy,ba as IsEAN,en as IsEmail,J as IsEmpty,br as IsEnum,Ia as IsEthereumAddress,sn as IsFQDN,Ie as IsFirebasePushId,un as IsFullWidth,Aa as IsHSL,pn as IsHalfWidth,ze as IsHash,hn as IsHexColor,$n as IsHexadecimal,Va as IsIBAN,Vn as IsIP,Ln as IsISBN,Bn as IsISIN,ne as IsISO31661Alpha2,re as IsISO31661Alpha3,_n as IsISO8601,La as IsISRC,Ge as IsISSN,Ta as IsIdentityCard,X as IsIn,ni as IsInstance,Ir as IsInt,kn as IsJSON,zn as IsJWT,x as IsLatLong,P as IsLatitude,Ba as IsLocale,R as IsLongitude,Gn as IsLowercase,An as IsMACAddress,_a as IsMagnetURI,ke as IsMilitaryTime,ka as IsMimeType,Yn as IsMobilePhone,oe as IsMongoId,le as IsMultibyte,dt as IsNegative,K as IsNotEmpty,Yr as IsNotEmptyObject,et as IsNotIn,yr as IsNumber,ra as IsNumberString,Tr as IsObject,za as IsOctal,N as IsOptional,Ga as IsPassportNumber,_e as IsPhoneNumber,Tn as IsPort,ct as IsPositive,Ya as IsPostalCode,nr as IsRFC3339,rr as IsRgbColor,or as IsSemVer,Ar as IsString,fe as IsSurrogatePair,be as IsUUID,Ae as IsUppercase,ye as IsUrl,gn as IsVariableWidth,Se as LENGTH,Ve as Length,Pe as MATCHES,pt as MAX,$t as MAX_DATE,Ce as MAX_LENGTH,gt as MIN,ht as MIN_DATE,xe as MIN_LENGTH,Be as Matches,mt as Max,Ot as MaxDate,Te as MaxLength,i as MetadataStorage,vt as Min,Mt as MinDate,Le as MinLength,Et as NOT_CONTAINS,H as NOT_EQUALS,Ct as NotContains,q as NotEquals,S as Validate,M as ValidateBy,E as ValidateIf,V as ValidateNested,C as ValidatePromise,s as ValidationError,o as ValidationTypes,l as Validator,A as ValidatorConstraint,Dr as arrayContains,Wr as arrayMaxSize,Hr as arrayMinSize,jr as arrayNotContains,Ur as arrayNotEmpty,Zr as arrayUnique,b as buildMessage,At as contains,_ as equals,g as getFromContainer,r as getMetadataStorage,Tt as isAlpha,Lt as isAlphanumeric,Er as isArray,_t as isAscii,ua as isBIC,sa as isBase32,kt as isBase64,ur as isBoolean,ta as isBooleanString,pa as isBtcAddress,zt as isByteLength,Gt as isCreditCard,Yt as isCurrency,ga as isDataURI,pr as isDate,Qe as isDateString,Bt as isDecimal,I as isDefined,rt as isDivisibleBy,ha as isEAN,nn as isEmail,z as isEmpty,hr as isEnum,$a as isEthereumAddress,rn as isFQDN,$e as isFirebasePushId,cn as isFullWidth,Na as isHSL,dn as isHalfWidth,We as isHash,vn as isHexColor,Mn as isHexadecimal,Ea as isIBAN,En as isIP,Dn as isISBN,jn as isISIN,te as isISO31661Alpha2,ae as isISO31661Alpha3,Un as isISO8601,Da as isISRC,Ze as isISSN,wa as isIdentityCard,Y as isIn,ti as isInstance,$r as isInt,Hn as isJSON,Wn as isJWT,T as isLatLong,L as isLatitude,ja as isLocale,B as isLongitude,Zn as isLowercase,Nn as isMACAddress,Ua as isMagnetURI,He as isMilitaryTime,Ha as isMimeType,Qn as isMobilePhone,se as isMongoId,ue as isMultibyte,lt as isNegative,G as isNotEmpty,Qr as isNotEmptyObject,nt as isNotIn,gr as isNumber,aa as isNumberString,wr as isObject,Wa as isOctal,Za as isPassportNumber,Ue as isPhoneNumber,wn as isPort,ot as isPositive,Qa as isPostalCode,tr as isRFC3339,ar as isRgbColor,sr as isSemVer,Nr as isString,pe as isSurrogatePair,ge as isURL,he as isUUID,Ne as isUppercase,In as isValidationOptions,mn as isVariableWidth,Ee as length,je as matches,ft as max,It as maxDate,we as maxLength,yt as min,bt as minDate,De as minLength,Vt as notContains,k as notEquals,h as registerDecorator,ii as registerSchema,m as useContainer,ei as validate,ai as validateOrReject,ri as validateSync};
//# sourceMappingURL=index.esm.min.js.map
