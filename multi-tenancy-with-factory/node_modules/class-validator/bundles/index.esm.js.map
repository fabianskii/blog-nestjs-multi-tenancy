{"version":3,"file":"index.esm.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidatorJS"],"mappings":"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"}