{"version":3,"file":"index.umd.min.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/decorator/common/Allow.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["args","this","undefined","type","target","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","groups","always","each","context","ValidationSchemaToMetadataTransformer","schema","metadatas","Object","keys","properties","forEach","property","validation","name","options","push","ValidationMetadata","getMetadataStorage","window","global","classValidatorMetadataStorage","MetadataStorage","validationMetadatas","length","transform","validationMetadata","_this","addValidationMetadata","metadata","constraintMetadatas","grouped","targetConstructor","targetSchema","originalMetadatas","filter","find","group","indexOf","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","ValidationError","shouldDecorate","hasParent","parentPath","propConstraintFailed","boldStart","boldEnd","join","formattedProperty_1","Number","isInteger","children","map","childError","toString","constructor","ValidationTypes","key","ValidationUtils","validationArguments","messageString","Array","constraint","index","replace","RegExp","value","targetName","isPromise","p","then","ValidationExecutor","object","validationErrors","metadataStorage","hasValidationMetaData","console","warn","validatorOptions","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","forbidUnknownValues","validationError","unknownValue","whitelist","definedMetadatas","IS_DEFINED","WHITELIST","Promise","PROMISE_VALIDATION","awaitingPromises","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","getTargetValidatorConstraints","customConstraintMetadata","async","ignoreAsyncValidations","Set","Map","val","validatedSubValues","from","values","isArray","subValue","instance","validate","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","every","isValid","_a","contexts","assign","_b","validatedValue","promise","execute","customConstraint","getConstraintType","customValidatorMetadata","dismissDefaultMessages","defaultMessage","replaceMessageSpecialTokens","validator","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","executor","coreValidate","reject","userContainer","userContainerOptions","defaultContainer","class_1","someClass","instances","getFromContainer","get","fallback","fallbackOnErrors","ConstraintMetadata","registerDecorator","validator_1","CustomConstraint","addConstraintMetadata","validationMetadataArgs","buildMessage","impl","eachPrefix","ValidateBy","isDefined","IS_LATLONG","isLatLong","IS_LATITUDE","isLatitude","IS_LONGITUDE","isLongitude","EQUALS","equals","comparison","NOT_EQUALS","notEquals","IS_EMPTY","isEmpty","IS_NOT_EMPTY","isNotEmpty","isIn","possibleValues","possibleValue","IS_NOT_IN","isNotIn","IS_DIVISIBLE_BY","isDivisibleBy","num","String","IS_POSITIVE","isPositive","IS_NEGATIVE","isNegative","max","min","MIN_DATE","minDate","date","Date","getTime","MAX_DATE","maxDate","CONTAINS","contains","seed","NOT_CONTAINS","notContains","IS_ALPHA","isAlpha","locale","ValidatorJS","IS_ALPHANUMERIC","isAlphanumeric","IS_DECIMAL","isDecimal","IS_ASCII","isAscii","IS_BASE64","isBase64","IS_BYTE_LENGTH","isByteLength","IS_CREDIT_CARD","isCreditCard","IS_CURRENCY","isCurrency","IS_EMAIL","isEmail","isFQDN","IS_FULL_WIDTH","isFullWidth","IS_HALF_WIDTH","isHalfWidth","IS_VARIABLE_WIDTH","isVariableWidth","IS_HEX_COLOR","isHexColor","IS_HEXADECIMAL","isHexadecimal","isValidationOptions","IS_MAC_ADDRESS","isMACAddress","isIP","version","versionStr","isPort","isISBN","isISIN","IS_ISO8601","isISO8601","isJSON","isJWT","IS_LOWERCASE","isLowercase","IS_MOBILE_PHONE","isMobilePhone","IS_ISO31661_ALPHA_2","isISO31661Alpha2","IS_ISO31661_ALPHA_3","isISO31661Alpha3","IS_MONGO_ID","isMongoId","IS_MULTIBYTE","isMultibyte","IS_SURROGATE_PAIR","isSurrogatePair","isURL","isUUID","IS_FIREBASE_PUSH_ID","isFirebasePushId","test","IS_UPPERCASE","isUppercase","isLength","MAX_LENGTH","maxLength","MIN_LENGTH","minLength","MATCHES","matches","pattern","modifiers","IS_PHONE_NUMBER","isPhoneNumber","region","phoneUtil","PhoneNumberUtil","getInstance","phoneNum","parseAndKeepRawInput","isValidNumber","IS_MILITARY_TIME","isMilitaryTime","isHash","algorithm","isISSN","IS_DATE_STRING","isDateString","IS_BOOLEAN_STRING","isBooleanString","isBoolean","IS_NUMBER_STRING","isNumberString","isNumeric","IS_BASE32","isBase32","isBIC","IS_BTC_ADDRESS","isBtcAddress","IS_DATA_URI","isDataURI","isEAN","IS_ETHEREUM_ADDRESS","isEthereumAddress","isHSL","isIBAN","IS_IDENTITY_CARD","isIdentityCard","isISRC","IS_LOCALE","isLocale","IS_MAGNET_URI","isMagnetURI","IS_MIME_TYPE","isMimeType","IS_OCTAL","isOctal","IS_PASSPORT_NUMBER","isPassportNumber","countryCode","IS_POSTAL_CODE","isPostalCode","IS_RFC_3339","isRFC3339","IS_RGB_COLOR","isRgbColor","includePercentValues","IS_SEM_VER","isSemVer","IS_BOOLEAN","Boolean","isDate","isNaN","IS_NUMBER","isNumber","Infinity","allowInfinity","allowNaN","maxDecimalPlaces","decimalPlaces","split","isFinite","isEnum","entity","k","isInt","IS_STRING","isString","IS_ARRAY","IS_OBJECT","isObject","ARRAY_CONTAINS","arrayContains","array","ARRAY_NOT_CONTAINS","arrayNotContains","ARRAY_NOT_EMPTY","arrayNotEmpty","ARRAY_MIN_SIZE","arrayMinSize","ARRAY_MAX_SIZE","arrayMaxSize","ARRAY_UNIQUE","arrayUnique","uniqueItems","a","b","c","IS_NOT_EMPTY_OBJECT","isNotEmptyObject","hasOwnProperty","IS_INSTANCE","isInstance","targetTypeConstructor","targetType","optionsOrValidationOptionsArg","validationOptionsArg","isMinLength","isMaxLength","modifiersOrAnnotationOptions","maxValue","minValue","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","condition","opts","isAsync","x","y","toLowerCase","addValidationSchema","iocContainer","schemaNameOrObject","validateOrReject","validateSync"],"mappings":"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"}