{"version":3,"file":"index.umd.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/validation/ValidationUtils.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidatorJS","PhoneNumberUtil"],"mappings":"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"}