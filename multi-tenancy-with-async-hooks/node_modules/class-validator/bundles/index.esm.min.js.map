{"version":3,"file":"index.esm.min.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/ValidationUtils.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n                });\n\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number greater than zero.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number smaller than zero.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidationMetadata","[object Object]","args","this","undefined","type","target","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","groups","always","each","context","ValidationSchemaToMetadataTransformer","schema","metadatas","Object","keys","properties","forEach","property","validation","name","options","push","getMetadataStorage","window","global","classValidatorMetadataStorage","MetadataStorage","hasValidationMetaData","validationMetadatas","length","transform","validationMetadata","addValidationMetadata","metadata","constraintMetadatas","grouped","targetConstructor","targetSchema","originalMetadatas","filter","find","group","indexOf","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","ValidationError","shouldDecorate","hasParent","parentPath","boldStart","boldEnd","propConstraintFailed","join","formattedProperty","Number","isInteger","children","map","childError","toString","constructor","ValidationTypes","key","isPromise","p","then","ValidationExecutor","validator","validatorOptions","object","validationErrors","metadataStorage","console","warn","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","forbidUnknownValues","validationError","value","unknownValue","whitelist","definedMetadatas","IS_DEFINED","WHITELIST","Promise","PROMISE_VALIDATION","awaitingPromises","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","getTargetValidatorConstraints","customConstraintMetadata","async","ignoreAsyncValidations","validationArguments","targetName","Array","Set","Map","validatedValue","instance","validate","promise","isValid","createValidationError","contexts","assign","val","validatedSubValues","from","values","isArray","subValue","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","every","index","execute","customConstraint","getConstraintType","customValidatorMetadata","dismissDefaultMessages","defaultMessage","messageString","constraint","replace","RegExp","replaceMessageSpecialTokens","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","executor","coreValidate","reject","defaultContainer","someClass","instances","userContainer","userContainerOptions","useContainer","iocContainer","getFromContainer","get","fallback","fallbackOnErrors","Allow","ConstraintMetadata","registerDecorator","addConstraintMetadata","validationMetadataArgs","buildMessage","impl","eachPrefix","ValidateBy","isDefined","IsDefined","IsOptional","ValidatorConstraint","isAsync","x","y","toLowerCase","Validate","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","ValidateIf","condition","ValidateNested","opts","ValidatePromise","IS_LATLONG","isLatLong","IsLatLong","IS_LATITUDE","isLatitude","IsLatitude","IS_LONGITUDE","isLongitude","IsLongitude","EQUALS","equals","comparison","Equals","NOT_EQUALS","notEquals","NotEquals","IS_EMPTY","isEmpty","IsEmpty","IS_NOT_EMPTY","isNotEmpty","IsNotEmpty","IS_IN","isIn","possibleValues","possibleValue","IsIn","IS_NOT_IN","isNotIn","IsNotIn","IS_DIVISIBLE_BY","isDivisibleBy","num","String","IsDivisibleBy","IS_POSITIVE","isPositive","IsPositive","IS_NEGATIVE","isNegative","IsNegative","MAX","max","Max","maxValue","MIN","min","Min","minValue","MIN_DATE","minDate","date","Date","getTime","MinDate","MAX_DATE","maxDate","MaxDate","CONTAINS","contains","seed","Contains","NOT_CONTAINS","notContains","NotContains","IS_ALPHA","isAlpha","locale","ValidatorJS","IsAlpha","IS_ALPHANUMERIC","isAlphanumeric","IsAlphanumeric","IS_DECIMAL","isDecimal","IsDecimal","IS_ASCII","isAscii","IsAscii","IS_BASE64","isBase64","IsBase64","IS_BYTE_LENGTH","isByteLength","IsByteLength","IS_CREDIT_CARD","isCreditCard","IsCreditCard","IS_CURRENCY","isCurrency","IsCurrency","IS_EMAIL","isEmail","IsEmail","IS_FQDN","isFQDN","IsFQDN","IS_FULL_WIDTH","isFullWidth","IsFullWidth","IS_HALF_WIDTH","isHalfWidth","IsHalfWidth","IS_VARIABLE_WIDTH","isVariableWidth","IsVariableWidth","IS_HEX_COLOR","isHexColor","IsHexColor","IS_HEXADECIMAL","isHexadecimal","IsHexadecimal","isValidationOptions","IS_MAC_ADDRESS","isMACAddress","IsMACAddress","optionsOrValidationOptionsArg","validationOptionsArg","IS_IP","isIP","version","versionStr","IsIP","IS_PORT","isPort","IsPort","IS_ISBN","isISBN","IsISBN","IS_ISIN","isISIN","IsISIN","IS_ISO8601","isISO8601","IsISO8601","IS_JSON","isJSON","IsJSON","IS_JWT","isJWT","IsJWT","IS_LOWERCASE","isLowercase","IsLowercase","IS_MOBILE_PHONE","isMobilePhone","IsMobilePhone","IS_ISO31661_ALPHA_2","isISO31661Alpha2","IsISO31661Alpha2","IS_ISO31661_ALPHA_3","isISO31661Alpha3","IsISO31661Alpha3","IS_MONGO_ID","isMongoId","IsMongoId","IS_MULTIBYTE","isMultibyte","IsMultibyte","IS_SURROGATE_PAIR","isSurrogatePair","IsSurrogatePair","IS_URL","isURL","IsUrl","IS_UUID","isUUID","IsUUID","IS_FIREBASE_PUSH_ID","isFirebasePushId","test","IsFirebasePushId","IS_UPPERCASE","isUppercase","IsUppercase","LENGTH","isLength","Length","isMinLength","isMaxLength","MAX_LENGTH","maxLength","MaxLength","MIN_LENGTH","minLength","MinLength","MATCHES","matches","pattern","modifiers","Matches","modifiersOrAnnotationOptions","IS_PHONE_NUMBER","isPhoneNumber","region","phoneUtil","PhoneNumberUtil","getInstance","phoneNum","parseAndKeepRawInput","isValidNumber","IsPhoneNumber","IS_MILITARY_TIME","isMilitaryTime","IsMilitaryTime","IS_HASH","isHash","algorithm","IsHash","IS_ISSN","isISSN","IsISSN","IS_DATE_STRING","isDateString","IsDateString","IS_BOOLEAN_STRING","isBooleanString","isBoolean","IsBooleanString","IS_NUMBER_STRING","isNumberString","isNumeric","IsNumberString","IS_BASE32","isBase32","IsBase32","IS_BIC","isBIC","IsBIC","IS_BTC_ADDRESS","isBtcAddress","IsBtcAddress","IS_DATA_URI","isDataURI","IsDataURI","IS_EAN","isEAN","IsEAN","IS_ETHEREUM_ADDRESS","isEthereumAddress","IsEthereumAddress","IS_HSL","isHSL","IsHSL","IS_IBAN","isIBAN","IsIBAN","IS_IDENTITY_CARD","isIdentityCard","IsIdentityCard","IS_ISRC","isISRC","IsISRC","IS_LOCALE","isLocale","IsLocale","IS_MAGNET_URI","isMagnetURI","IsMagnetURI","IS_MIME_TYPE","isMimeType","IsMimeType","IS_OCTAL","isOctal","IsOctal","IS_PASSPORT_NUMBER","isPassportNumber","countryCode","IsPassportNumber","IS_POSTAL_CODE","isPostalCode","IsPostalCode","IS_RFC_3339","isRFC3339","IsRFC3339","IS_RGB_COLOR","isRgbColor","includePercentValues","IsRgbColor","IS_SEM_VER","isSemVer","IsSemVer","IS_BOOLEAN","Boolean","IsBoolean","IS_DATE","isDate","isNaN","IsDate","IS_NUMBER","isNumber","Infinity","allowInfinity","allowNaN","maxDecimalPlaces","decimalPlaces","split","isFinite","IsNumber","IS_ENUM","isEnum","entity","k","IsEnum","IS_INT","isInt","IsInt","IS_STRING","isString","IsString","IS_ARRAY","IsArray","IS_OBJECT","isObject","IsObject","ARRAY_CONTAINS","arrayContains","array","ArrayContains","ARRAY_NOT_CONTAINS","arrayNotContains","ArrayNotContains","ARRAY_NOT_EMPTY","arrayNotEmpty","ArrayNotEmpty","ARRAY_MIN_SIZE","arrayMinSize","ArrayMinSize","ARRAY_MAX_SIZE","arrayMaxSize","ArrayMaxSize","ARRAY_UNIQUE","arrayUnique","uniqueItems","a","b","c","ArrayUnique","IS_NOT_EMPTY_OBJECT","isNotEmptyObject","hasOwnProperty","IsNotEmptyObject","IS_INSTANCE","isInstance","targetTypeConstructor","IsInstance","targetType","schemaNameOrObject","validateOrReject","validateSync","registerSchema","addValidationSchema"],"mappings":"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"}